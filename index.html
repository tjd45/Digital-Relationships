<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<title>Digital Relationships: Thomas Davidson 2020</title>
	<script type="text/javascript" src="d3.js"></script>
	<style type="text/css">
		#svg-graph {
			background-color: black;
			margin-right: 8px;
			float: left;

		}

		#svg_messages_div {
			display: block;

			margin: 10px;
		}

		#messageBox {
			box-sizing: border-box;
			resize: none;
			overflow-x: hidden;
			background-color: #BBBBBB;
		}

		/* rect:hover {
			fill: orange;
		} */

		.fillerRect {
			opacity: 0.0;
		}

		.fillerRect:hover {
			fill: white;
			opacity: 0.3;
		}

		.fillerSegment {
			opacity: 0.0;
		}

		.fillerSegment:hover {
			fill: white;
			opacity: 0.3;
		}

		#tooltip {
			position: absolute;
			width: 300px;
			height: auto;
			padding: 10px;
			background-color: white;
			color: black;
			-webkit-border-radius: 10px;
			-moz-border-radius: 10px;
			border-radius: 10px;
			-webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			-moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			pointer-events: none;
		}

		#tooltip.hidden {
			display: none;
		}

		#tooltip p {
			margin: 0;
			font-family: sans-serif;
			font-size: 16px;
			line-height: 20px;
			white-space: pre-wrap;
		}

		.axis path,
		.axis line {
			stroke: white;
			shape-rendering: crispEdges;
		}

		.axis text {
			fill: white;
		}

		.controls {
			display: block;
			height: 210px;
			margin: 10px;
		}

		.controlsLeft {
			height: 100%;
			width: 330px;
			float: left;


		}

		.controlsMiddle {
			height: 100%;
			width: 700px;
			float: left;


		}

		.controlsRight {
			height: 100%;
	
			float: left;

		}

		.floated {
			float: left;
			margin-right: 5px;
		}

		#summaryText {
			white-space: pre-wrap;

		}

		.clockText {
			color: white
		}

		.colourSelector {
			margin-right: 10px;
		}

		.header {
			padding: 10px;
			text-align: left;
			background: #333333;
			color: white;
			font-size: 15px;
			border-bottom: 1px white solid;
			margin-bottom: 0px;
			margin-top: 0px;
			font-family: courier, arial, helvetica;
		}

		h1 {
			margin: 0px;
			margin-right: 5px;

		}

	

		html,
		body {
			margin: 0;
			padding: 0;
			background-color: #333333;
			color: white;

		}

		

	

		#messageBox::-webkit-scrollbar-thumb {
			background: #999999;
			border: 1px solid #333333;
			border-radius: 50px;
		}

		#messageBox::-webkit-scrollbar-thumb:hover {
			background: #777777;
		}

		#messageBox::-webkit-scrollbar-thumb:active {
			background: #777777;
		}

		#messageBox::-webkit-scrollbar-track {
			background: #333333;
			border: 0px none #444444;
			border-radius: 53px;
		}

		#messageBox::-webkit-scrollbar-track:hover {
			background: #333333;
		}

		#messageBox::-webkit-scrollbar-track:active {
			background: #333333;
		}

		::-webkit-scrollbar {
			width: 11px;
			height: 11px;
		}

		::-webkit-scrollbar-button {
			width: 0px;
			height: 0px;
		}

		::-webkit-scrollbar-thumb {
			background: #333333;
			border: 1px solid #777777;
			border-radius: 50px;
		}

		::-webkit-scrollbar-thumb:hover {
			background: #AAAAAA;
		}

		::-webkit-scrollbar-thumb:active {
			background: #999999;
		}

		::-webkit-scrollbar-track {
			background: #BBBBBB;
			border: 0px none #ffffff;
			border-radius: 53px;
		}

		::-webkit-scrollbar-track:hover {
			background: #444444;
		}

		::-webkit-scrollbar-track:active {
			background: #444444;
		}

		::-webkit-scrollbar-corner {
			background: transparent;
		}

		
	</style>
</head>

<body>
	<div id="tooltip" class="hidden">
		<p><span id="value">1000</span></p>
	</div>

	<div class="header">
		<h1>Digital Relationships</h1>

	</div>

	<div class="controls">
		<div class="controlsLeft">
			<input type="file" id="selectFiles" value="Import" /><br />
			<button id="import">Import</button>

			<button id="clear">Clear</button>

			<p>
				<input type="radio" name="periodPreset" value="Hour"> Hour
				<input type="radio" name="periodPreset" value="Day"> Day
				<input type="radio" name="periodPreset" value="Week" checked="true"> Week
				<input type="radio" name="periodPreset" value="Month"> Month
				<input type="radio" name="periodPreset" value="Year"> Year
			</p>

			Your Name: <input type="text" id="uname" name="uname"> <button id="update">Update</button> <br><br>


			<p>
				<input type="radio" name="clockOrTimeline" value="Timeline" checked="true"> Timeline
				<input type="radio" name="clockOrTimeline" value="Clock"> Clock
			</p>

			<!-- <textarea id="result">
		</textarea> -->

		</div>
		<div class="controlsMiddle">
			<p>
				<input type="radio" name="messagesOrCharacters" value="Messages" checked="true"> Individual Messages
				<input type="radio" name="messagesOrCharacters" value="Characters"> Total Characters
			</p>

			<label class="floated" for="startDate">Start Date:</label>
			<input class="floated" type="date" id="startDate" name="startDate">
			<label class="floated" for="endDate">End Date:</label>
			<input class="floated" type="date" id="endDate" name="endDate">

			<button id="updateDates" class="floated">Update Dates</button>
			<button id="resetDates" class="floated">Reset Dates</button>

			<br />
			<p id="summaryText"></p>

		</div>
		<div class="controlsRight">
			<input class="colourSelector" type="color" id="sendColour" value="#0000ff"><label id="sendColourLabel"
				for="sendColour"></label>
			<br />
			<input class="colourSelector" type="color" id="rcvColour" value="#00ff00"><label id="rcvColourLabel"
				for="rcvColour"></label>
		</div>


	</div>







	<script type="text/javascript">
		var parseTime = d3.timeParse("%d/%m/%Y")

		var fullTime = d3.timeFormat("%e %b %Y %X")
		var fullShortTime = d3.timeFormat("%e %b %Y %I%p")
		var justDate = d3.timeFormat("%e %b %Y")
		var datePickerFormat = d3.timeFormat("%Y-%m-%d")
		var periods = {
			Hour: 3600000,
			Day: 86400000,
			Week: 86400000 * 7,
			Month: 86400000 * 30,
			Year: 86400000 * 365
		}

		var hourRangeStrings = [
			"Midnight to 1 am", "1am to 2am", "2am to 3am", "3am to 4am", "4am to 5am", "5am to 6am", "6am to 7am",
			"7am to 8am", "8am to 9am", "9am to 10am", "10am to 11am", "11am to Midday", "Midday to 1pm", "1pm to 2pm",
			"2pm to 3pm", "3pm to 4pm", "4pm to 5pm", "5pm to 6pm", "6pm to 7pm", "7pm to 8pm", "8pm to 9pm", "9pm to 10pm",
			"10pm to 11pm", "11pm to Midnight"
		]
		var day_in_ms = 86400000
		var periodString = "Week"
		var period = periods.Week

		var indivMessages = true
		var timeline = true

		var userName = "Tom Davidson"
		var sendColour = document.getElementById('sendColour').value
		var rcvColour = document.getElementById('rcvColour').value

		var colourMap = { "Tom Davidson": "#1fc3ff" }
		var defaultReceiveColour = "#00ff00"

		var offsets = {}

		document.getElementById('update').onclick = function () {
			var newUser = d3.select("#uname").property("value")

			if (newUser.length > 0) {
				userName = newUser
			}

			if (currentJson) {
				redraw(currentJson)
			}


		}

		document.getElementById('sendColour').onchange = function () {
			sendColour = this.value
			if (currentJson)
				colourMap[userName] = sendColour
			redraw(currentJson)
		}

		document.getElementById('rcvColour').onchange = function () {
			rcvColour = this.value
			if (currentJson)
				colourMap[currentJson.title] = rcvColour
			redraw(currentJson)
		}



		d3.select("#updateDates")
			.on("click", function () {

				startTS = new Date(document.getElementById("startDate").value).getTime()
				endTS = new Date(document.getElementById("endDate").value).getTime()

				firstTimestamp = startTS
				lastTimestamp = endTS

				if (currentJson) {
					redraw(currentJson)
				}


			})

		d3.select("#resetDates")
			.on("click", function () {

				if (currentJson) {
					updateDateRange(currentJson)
					redraw(currentJson)
				}




			})

		d3.selectAll("input[name='periodPreset']")
			.on("click", function () {
				var view = d3.select(this).node().value;
				if (periods[view]) {

					period = periods[view]
					periodString = view

					if (currentJson) {
						redraw(currentJson)
					}
				}



			})

		d3.selectAll("input[name='messagesOrCharacters']")
			.on("click", function () {
				var view = d3.select(this).node().value;
				if (view == "Messages") {
					indivMessages = true
				} else {
					indivMessages = false
				}

				if (currentJson) {
					redraw(currentJson)
				}



			})

		d3.selectAll("input[name='clockOrTimeline']")
			.on("click", function () {
				var view = d3.select(this).node().value;
				if (view == "Clock") {
					timeline = false
				} else {
					timeline = true
				}

				if (currentJson) {
					redraw(currentJson)
				}




			})

		function calcTooltipText(d, i) {
			var thisString = ""
			var CorM = indivMessages ? "messages" : "characters"

			if (timeline) {
				if (["Week", "Month", "Year"].includes(periodString)) {
					thisString += justDate(firstTimestamp + (d.key * period)) + " to " + justDate(firstTimestamp + ((d.key + 1) * period))
				} else {
					if (periodString === "Day") {
						thisString += justDate(firstTimestamp + (d.key * period))
					} else {
						thisString += fullShortTime(firstTimestamp + (d.key * period))
					}
				}
				thisString += "\n" + (sentMessCount[d.key] ? sentMessCount[d.key] : 0) + " " + CorM + " sent, " + (rcvMessCount[d.key] ? rcvMessCount[d.key] : 0) + " received"
			} else {
				thisString += "Hour " + i + " : " + hourRangeStrings[i] +

					"\n" + (d[2] == 0 ? d[0] : d[1]) + " " + CorM + " sent, " + (d[2] == 0 ? d[1] : d[0]) + " received";

				if (d[2] == 0) {

				}
			}
			return thisString
		}

		function printMessages(key) {
			document.getElementById('messageBox').value = ""
			document.getElementById('messageBox').scrollTop = 0
			var sLength = 0
			var rLength = 0

			if (sentMess[key]) {
				sLength = sentMess[key].length
			}

			if (rcvMess[key]) {
				rLength = rcvMess[key].length
			}

			var total = sLength + rLength

			var scount = 0
			var rcount = 0

			// console.log("-----------------------------")

			for (var i = 0; i < total; i++) {
				var r = false

				if (scount > sLength - 1) {
					r = true
				} else {
					if (rcount > rLength - 1) {
						r = false
					} else {
						if (sentMess[key][scount].timestamp < rcvMess[key][rcount].timestamp) {
							r = false
						} else {
							r = true
						}
					}




				}

				if (r) {
					printMessage(people[1], rcvMess[key][rcount])
					rcount++

				} else {
					printMessage(people[0], sentMess[key][scount])
					scount++
				}



			}


		}

		function printMessage(person, message) {
			document.getElementById('messageBox').value += fullTime(message.timestamp) + " " + person + ": " + message.content + "\n"
			// console.log(fullTime(message.timestamp) + " " + person + ": " + message.content)
		}

		var currentJson
		function sameParticipants(j1, j2) {
			if (j1) {
				return j1.title == j2.title

				//return arraysEqual(j1.participants, j2.participants)

			} else {
				return false
			}
		}

		function arraysEqual(_arr1, _arr2) {
			if (
				!Array.isArray(_arr1)
				|| !Array.isArray(_arr2)
				|| _arr1.length !== _arr2.length
			) {
				return false;
			}

			const arr1 = _arr1.concat().sort();
			const arr2 = _arr2.concat().sort();

			for (let i = 0; i < arr1.length; i++) {
				if (arr1[i].name !== arr2[i].name) {
					return false;
				}
			}

			return true;
		}

		function clearGraph() {
			console.log("Clearing graph")
			clock.selectAll("*").remove()
			svg.selectAll(".axis").remove()
			document.getElementById('messageBox').value = ""
			bottomBars.selectAll("*").remove()
			topBars.selectAll("*").remove()
		}

		function firstAndLastTimestamps(j) {
			var firstTimestamp = j.messages[j.messages.length - 1].timestamp_ms
			var lastTimestamp = j.messages[0].timestamp_ms

			return [firstTimestamp, lastTimestamp]
		}

		function combineJson(j1, j2) {
			var oldDatats = firstAndLastTimestamps(j1)
			var newDatats = firstAndLastTimestamps(j2)

			//check if it comes before
			if (newDatats[0] < oldDatats[0]) {
				console.log("New data older")
				var newMessages = j1.messages.concat(j2.messages)
			} else {
				if (newDatats[0] > oldDatats[1]) {
					console.log("New data newer")
					var newMessages = j2.messages.concat(j1.messages)
				} else {
					var newMessages = j1.messages
				}
			}

			j1.messages = newMessages

			return j1
		}

		function getFirstAndLastDays(j) {
			var firstDay = Math.floor(j.messages[j.messages.length - 1].timestamp_ms / (day_in_ms)) * day_in_ms
			var lastDay = Math.floor(j.messages[0].timestamp_ms / (day_in_ms) + 1) * day_in_ms

			return [firstDay, lastDay]
		}

		function updateDateRange(j) {
			var FandL = firstAndLastTimestamps(j)
			var firstDay = Math.floor(FandL[0] / (day_in_ms)) * day_in_ms
			var lastDay = Math.floor(FandL[1] / (day_in_ms) + 1) * day_in_ms

			d3.select("#startDate").property("value", datePickerFormat(firstDay))
			d3.select("#endDate").property("value", datePickerFormat(lastDay))


			firstTimestamp = FandL[0]
			lastTimestamp = FandL[1]
		}


		var key = function (d) {
			return d.key;
		};

		document.getElementById('clear').onclick = function () {
			currentJson = undefined
			clearGraph()
		}

		document.getElementById('import').onclick = function () {

			var files = document.getElementById('selectFiles').files;

			if (files.length <= 0) {
				return false;
			}

			var fr = new FileReader();

			fr.onload = function (e) {

				var result = JSON.parse(e.target.result);

				if (sameParticipants(currentJson, result)) {

					var newResult = combineJson(currentJson, result)
					result = newResult
				}

				currentJson = result

				// var formatted = JSON.stringify(result, null, 2);
				// document.getElementById('result').value = formatted;

				updateDateRange(result)
				// FandL = getFirstAndLastDays(result)
				// d3.select("#startDate").attr("value",datePickerFormat(FandL[0]))
				// d3.select("#endDate").attr("value",datePickerFormat(FandL[1]))

				// fandl = firstAndLastTimestamps(result)
				// firstTimestamp = fandl[0]
				// lastTimestamp = fandl[1]


				redraw(result)


			}

			fr.readAsText(files.item(0));
		};

		console.log(window.innerHeight)

		var otherElHeights = d3.select(".controls").node().getBoundingClientRect().height + 
							d3.select(".header").node().getBoundingClientRect().height + 40;

		var otherElWidths = 450 + 20 + 8 + 11;
		
		var w = window.innerWidth - otherElWidths;
		var h = window.innerHeight - otherElHeights;
		var padding = 20;

		var svg = d3.select("body")
			.append("div")
			.attr("id", "svg_messages_div")
			.append("svg")
			.attr("width", w)
			.attr("height", h)
			.attr("id", "svg-graph");

		var clock = svg.append("g")
			.attr("transform", "translate(" + w / 2 + "," + h / 2 + ")")

		d3.select("#summaryText").text("Message between \nFirst message: ,Last message: \nMessages sent: " +
			", Messages received: \nCharacters sent: , Characters received: ")

		var topBars = svg.append("g")
			.attr("class", "top-bars")

		var bottomBars = svg.append("g")
			.attr("class", "bottom-bars")

		var messageBox = d3.select("#svg_messages_div")
			.append("textarea")
			.attr("readonly", true)
			.attr("id", "messageBox")
			.style("width", 450 + "px")
			.style("height", h + "px")

		function setClockScales(hourData) {
			var maxVal = 0

			for (el in hourData) {
				if (hourData[el][0] + hourData[el][1] > maxVal) {
					maxVal = hourData[el][0] + hourData[el][1]
				}
			}

			xClock = d3.scaleBand()
				.range([0, 2 * Math.PI])
				.domain(d3.range(24))

			yClock = d3.scaleLinear()
				.range([0, Math.min(h, w) / 2 - 120])
				.domain([0, maxVal])
		}

		function setScales(s, r) {


			var maxSKey = d3.max(s, function (d) { return d.key; })
			var maxRKey = d3.max(r, function (d) { return d.key; })

			if (!maxSKey) maxSKey = 0
			if (!maxRKey) maxRKey = 0


			var maxKey = Math.max(maxSKey, maxRKey) + 1;




			xScale = d3.scaleBand()
				.domain(d3.range(maxKey))
				.range([0, w])
				.paddingInner(0.05);

			svg.select(".axis").remove()

			var gap = Math.floor(maxKey / 10)

			if (gap == 0) {
				gap++
			}


			var ticks = []
			for (i = 0; i < maxKey; i += gap) {
				ticks.push(i)
			}

			var xAxis = d3.axisBottom()
				.scale(xScale)
				.tickValues(ticks)
				.tickFormat(d => (justDate(firstTimestamp + (d * period))));

			var falseXAxis = d3.axisTop()
				.scale(xScale)
				.tickValues(ticks)
				.tickFormat(d => "");

			svg.append("g")
				.attr("class", "axis")
				.attr("transform", "translate(0," + (h / 2 - 12) + ")")
				.call(xAxis)

			svg.append("g")
				.attr("class", "axis")
				.attr("transform", "translate(0," + (h / 2 + 12) + ")")
				.call(falseXAxis)

			var maxSValue = d3.max(s, function (d) { return d.value; })
			var maxRValue = d3.max(r, function (d) { return d.value; })

			if (!maxSValue) maxSValue = 0
			if (!maxRValue) maxRValue = 0

			var maxValue = Math.max(maxSValue, maxRValue);

			yScale = d3.scaleLinear()
				.domain([0, maxValue])
				.range([0, h / 2 - padding]);
		}

		function drawTopBars(dataToDraw, thisConv) {
			var name = thisConv

			//draw the bars
			topBars.selectAll("rect")
				.data(dataToDraw, key)
				.enter()
				.append("rect")
				.attr("x", function (d) {
					return xScale(d.key);
				})
				.attr("y", function (d) {
					return h / 2 - 12 - yScale(d.value) //- offsets[d.key][name].Offset;
				})
				.attr("width", xScale.bandwidth())
				.attr("height", function (d) {
					return yScale(d.value);
				})
				.attr("fill", sendColour)
				;

			topBars.append("g")
				.selectAll("rect")
				.data(dataToDraw, key)
				.enter()
				.append("rect")
				.attr("class", "fillerRect")
				.attr("x", function (d) {
					return xScale(d.key);
				})
				.attr("y", function (d) {
					return h / 2 - 12 - yScale(d.value) //- offsets[d.key][name].Offset;
				})
				.attr("width", xScale.bandwidth())
				.attr("height", function (d) {
					return yScale(d.value);
				})
				.attr("fill", sendColour)
				.on("mouseover", function (d) {

					//Get this bar's x/y values, then augment for the tooltip
					var xPosition = parseFloat(d3.select(this).attr("x")) + xScale.bandwidth() / 2;
					var yPosition = parseFloat(d3.select(this).attr("y")) / 2 + h / 2;

					//Update the tooltip position and value
					d3.select("#tooltip")
						.style("left", xPosition + "px")
						.style("top", yPosition + "px")
						.select("#value")
						.text(calcTooltipText(d))

					//Show the tooltip
					d3.select("#tooltip").classed("hidden", false);

				})
				.on("mouseout", function () {

					//Hide the tooltip
					d3.select("#tooltip").classed("hidden", true);

				})
				.on("click", function (d) {
					printMessages(d.key)
				});


		}

		function drawBottomBars(dataToDraw) {
			//Create bottom bars
			bottomBars.selectAll("rect")
				.data(dataToDraw, key)
				.enter()
				.append("rect")
				.attr("x", function (d, i) {
					return xScale(d.key);
				})
				.attr("y", function (d) {
					return h / 2 + 12;
				})
				.attr("width", xScale.bandwidth())
				.attr("height", function (d) {

					return yScale(d.value);
				})
				.attr("fill", rcvColour)
				;

			bottomBars.append("g")
				.selectAll("rect")
				.data(dataToDraw, key)
				.enter()
				.append("rect")
				.attr("class", "fillerRect")
				.attr("x", function (d, i) {
					return xScale(d.key);
				})
				.attr("y", function (d) {
					return h / 2 + 12;
				})
				.attr("width", xScale.bandwidth())
				.attr("height", function (d) {

					return yScale(d.value);
				})
				.attr("fill", rcvColour)
				.on("mouseover", function (d) {

					//Get this bar's x/y values, then augment for the tooltip
					var xPosition = parseFloat(d3.select(this).attr("x")) + xScale.bandwidth() / 2;
					var yPosition = parseFloat(d3.select(this).attr("y")) / 2 + h / 2;

					//Update the tooltip position and value
					d3.select("#tooltip")
						.style("left", xPosition + "px")
						.style("top", yPosition + "px")
						.select("#value")
						.text(calcTooltipText(d))
					//Show the tooltip
					d3.select("#tooltip").classed("hidden", false);

				})
				.on("mouseout", function () {

					//Hide the tooltip
					d3.select("#tooltip").classed("hidden", true);

				})
				.on("click", function (d) {
					printMessages(d.key)
				});;

		}

		function drawClock(data) {
			var clockRad = Math.min(h, w) / 2 - 100
			clock.append("circle")
				.style("fill", "#999999")
				.attr("r", clockRad)
				.attr("cx", 0)
				.attr("cy", 0)

			clock.append("text")
				.attr("class", "clockText")
				.style('fill', 'white')
				.attr("x", -18)
				.attr("y", - clockRad - 50)
				.text("00:00")

			clock.append("text")
				.attr("class", "clockText")
				.style('fill', 'white')
				.attr("x", -18)
				.attr("y", clockRad + 50)
				.text("12:00")

			clock.append("text")
				.attr("class", "clockText")
				.style('fill', 'white')
				.attr("x", clockRad + 50)
				.attr("y", 9)
				.text("06:00")

			clock.append("text")
				.attr("class", "clockText")
				.style('fill', 'white')
				.attr("x", - clockRad - 86)
				.attr("y", 9)
				.text("18:00")

			var colours = [sendColour, rcvColour]



			clock.append("g")
				.selectAll("path")
				.data(data)
				.enter()
				.append("path")
				.attr("fill", function (d) { return colours[d[2]] })
				.attr("d", d3.arc()     // imagine your doing a part of a donut plot
					.innerRadius(0)
					.outerRadius(function (d) { return yClock(d[0]); })
					.startAngle(function (d, i) { return xClock(i); })
					.endAngle(function (d, i) { return xClock(i) + xClock.bandwidth(); })
					.padAngle(0.01)
					.padRadius(0))


			// Add second set
			clock.append("g")
				.selectAll("path")
				.data(data)
				.enter()
				.append("path")
				.attr("fill", function (d) { return colours[1 - d[2]] })
				.attr("d", d3.arc()     // imagine your doing a part of a donut plot
					.innerRadius(function (d) { return yClock(d[0]) })
					.outerRadius(function (d) { return yClock(d[0]) + yClock(d[1]); })
					.startAngle(function (d, i) { return xClock(i); })
					.endAngle(function (d, i) { return xClock(i) + xClock.bandwidth(); })
					.padAngle(0.01)
					.padRadius(0))

			// Add halfway markers
			clock.append("g")
				.selectAll("path")
				.data(data)
				.enter()
				.append("path")
				.attr("fill", function (d) { return "black" })
				.attr("d", d3.arc()     // imagine your doing a part of a donut plot
					.innerRadius(function (d) { return (yClock(d[0] + d[1])) / 2 - 1 })
					.outerRadius(function (d) { return (yClock(d[0] + d[1])) / 2 + 1 })
					.startAngle(function (d, i) { return xClock(i) + (Math.PI / 96); })
					.endAngle(function (d, i) { return xClock(i) + xClock.bandwidth() - (Math.PI / 96); })
					.padAngle(0.01)
					.padRadius(0))


			// Add dummy segments for hover/tooltip
			clock.append("g")
				.selectAll("path")
				.data(data)
				.enter()
				.append("path")
				.attr("fill", "#ffffff")
				.attr("class", "fillerSegment")
				.attr("d", d3.arc()     // imagine your doing a part of a donut plot
					.innerRadius(0)
					.outerRadius(clockRad)
					.startAngle(function (d, i) { return xClock(i); })
					.endAngle(function (d, i) { return xClock(i) + xClock.bandwidth(); })
					.padAngle(0.01)
					.padRadius(0))
				.on("mouseover", function (d, i) {

					var xPosition = d3.event.pageX - document.getElementById('svg-graph').getBoundingClientRect().x + 10
					var yPosition = d3.event.pageY - document.getElementById('svg-graph').getBoundingClientRect().y + 150

					//Update the tooltip position and value
					d3.select("#tooltip")
						.style("left", xPosition + "px")
						.style("top", yPosition + "px")
						.select("#value")
						.text(calcTooltipText(d, i))

					//Show the tooltip
					d3.select("#tooltip").classed("hidden", false);

				})
				.on("mouseout", function () {

					//Hide the tooltip
					d3.select("#tooltip").classed("hidden", true);

				})

		}

		function handleColours(json) {
			document.getElementById('sendColourLabel').innerHTML = userName;
			document.getElementById('rcvColourLabel').innerHTML = json.title;

			if (colourMap[userName]) {
				document.getElementById('sendColour').value = colourMap[userName];
				sendColour = colourMap[userName];
			} else {
				colourMap[userName] = document.getElementById('sendColour').value;
			}

			if (colourMap[json.title]) {
				document.getElementById('rcvColour').value = colourMap[json.title];
				rcvColour = colourMap[json.title];
			} else {
				document.getElementById('rcvColour').value = defaultReceiveColour;
				colourMap[json.title] = document.getElementById('rcvColour').value;
				rcvColour = colourMap[json.title];
			}

		}

		function redraw(json) {
			clearGraph()

			handleColours(json)

			var output = handleJson(json, period)

			//handleOffsets(output[0], output[3])

			if (timeline) {
				setScales(output[0], output[1])

				drawTopBars(output[0], output[3])
				drawBottomBars(output[1])
			} else {
				setClockScales(output[2])

				drawClock(output[2])
			}
		}

		function handleOffsets(j, name) {
			//BACKBURNER for timebeing

			for (x in j) {
				var jKey = j[x].key
				var jValue = j[x].value
				if (offsets.hasOwnProperty(jKey)) {
					var fillerOffset = 0

					for (var person in offsets[jKey]) {
						if (offsets[jKey][person].Value < jValue) {
							offsets[jKey][person].Offset += jValue
						} else {
							fillerOffset += offsets[jKey][person].Value
						}
					}
					offsets[jKey][name] = { "Value": jValue, "Offset": fillerOffset }
					console.log("Recalculating offset")
					console.log(offsets[jKey])
				} else {
					offsets[jKey] = {
						[name]: { "Value": jValue, "Offset": 0 }

					}
				}
			}

			console.log(offsets)

		}

		function handleJson(rawJson, period) {

			people = [userName]

			for (person in rawJson.participants) {
				if (rawJson.participants[person].name != userName) {
					people.push(rawJson.participants[person].name)
				}
			}

			var thisConvID = rawJson.title

			var numSent = 0
			var numRcv = 0
			var numCharSent = 0
			var numCharRcv = 0


			// firstTimestamp = Math.floor(rawJson.messages[rawJson.messages.length - 1].timestamp_ms / (day_in_ms)) * day_in_ms
			// lastTimestamp = Math.floor(rawJson.messages[0].timestamp_ms / (day_in_ms) + 1) * day_in_ms



			var actualFirstTimestamp
			var actualLastTimestamp


			sentMessCount = {}
			sentMess = {}
			rcvMessCount = {}
			rcvMess = {}

			var firstSet = false

			var lastDayNum = Math.floor((lastTimestamp - firstTimestamp) / period)

			var oldTimestamp = 0

			var thisMessLen = 0
			var charCounter = 0

			//First message: 30 Jan 2020 10:22:32 AM
			// Last Message: 20 Nov 2020 1:08:03 AM

			var hoursMsg = new Array(24)
			for (var i = 0; i < 24; i++) {
				hoursMsg[i] = [0, 0]
			}

			for (var i = rawJson.messages.length - 1; i > -1; i--) {

				var thisMess = rawJson.messages[i]

				var dayNum = Math.floor((thisMess.timestamp_ms - firstTimestamp) / period)

				var hourNum = new Date(thisMess.timestamp_ms).getHours()

				if (dayNum >= 0 && dayNum <= lastDayNum && (thisMess.type === "Generic" || thisMess.type === "Share")) {

					charCounter = (thisMess.content ? thisMess.content.length : 0)

					if (!firstSet) {

						actualFirstTimestamp = thisMess.timestamp_ms
						firstSet = true
					}
					actualLastTimestamp = thisMess.timestamp_ms


					if (indivMessages) {
						thisMessLen = 1
					} else {
						thisMessLen = (thisMess.content ? thisMess.content.length : 0)
					}

					if (thisMess.sender_name === userName) {

						numSent++
						numCharSent += charCounter
						if (sentMessCount[dayNum]) {

							sentMessCount[dayNum] = sentMessCount[dayNum] + thisMessLen
							sentMess[dayNum].push({ timestamp: thisMess.timestamp_ms, content: thisMess.content })

						} else {
							sentMessCount[dayNum] = thisMessLen
							sentMess[dayNum] = [{ timestamp: thisMess.timestamp_ms, content: thisMess.content }]
						}

						hoursMsg[hourNum][0] += thisMessLen


					} else {
						numRcv++
						numCharRcv += charCounter
						if (rcvMessCount[dayNum]) {
							rcvMessCount[dayNum] = rcvMessCount[dayNum] + thisMessLen
							rcvMess[dayNum].push({ timestamp: thisMess.timestamp_ms, content: thisMess.content })
						} else {
							rcvMessCount[dayNum] = thisMessLen
							rcvMess[dayNum] = [{ timestamp: thisMess.timestamp_ms, content: thisMess.content }]
						}

						hoursMsg[hourNum][1] += thisMessLen
					}
				}

			}

			for (var i = 0; i < 24; i++) {
				if (hoursMsg[i][0] > hoursMsg[i][1]) {
					hoursMsg[i].push(0)
				} else {
					var temp = hoursMsg[i][1]
					hoursMsg[i][1] = hoursMsg[i][0]
					hoursMsg[i][0] = temp
					hoursMsg[i].push(1)
				}
			}

			var partString = ""

			for (p in people) {
				partString += people[p] + " and "
			}

			partString = partString.substring(0, partString.length - 5)

			d3.select("#summaryText").text("Message between " + partString + "\nFirst message: " + fullTime(actualFirstTimestamp) +
				", Last message: " + fullTime(actualLastTimestamp) + "\nMessages sent: " + numSent +
				", Messages received: " + numRcv + "\nCharacters sent: " + numCharSent +
				", Characters received: " + numCharRcv)
			// console.log("First message: " + fullTime(actualFirstTimestamp))
			// console.log("Last Message: " + fullTime(actualLastTimestamp))

			// console.log("Messages sent: " + numSent);
			// console.log("Messages received: " + numRcv);

			var sentMessArray = []
			var rcvMessArray = []



			for (var i in sentMessCount) {
				sentMessArray.push({ key: parseInt(i), value: sentMessCount[i], messages: sentMess[i] })
			}

			for (var i in rcvMessCount) {
				rcvMessArray.push({ key: parseInt(i), value: rcvMessCount[i], messages: rcvMess[i] })
			}



			return [sentMessArray, rcvMessArray, hoursMsg, thisConvID]


		}


	</script>

</body>

</html>